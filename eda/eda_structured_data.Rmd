---
title: "MIMIC III Dataset - Structured Data Analysis"
author: "Evan Canfield"
date: "10/31/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Library
The following are library packages used in this analysis.
```{r library}
if (!require(pacman)) {install.packages('pacman')} 
p_load(
    caTools
  , data.table
  , feather
  , here
  , Hmisc
  , janitor
  , lubridate
  , R.utils
  , skimr
  , stringr
  , tidyverse
)
```

# Set Seed
```{r}
set.seed(5590)
```


# Import
```{r}
#chartevents <- read_feather(here("data/raw_feather/chartevents.feather"))
#note_events <- read_feather(here("data/raw_feather/noteevents.feather"))

#here::here("data/raw_feather/labevents.feather")

# Lab Results
lab_events <- read_feather(here::here("data/raw_feather/labevents.feather"))

#Lab Item Definitions
d_labitems <- read_feather(here::here("data/raw_feather/d_labitems.feather"))

#Admissions
admissions <- read_feather(here::here("data/raw_feather/admissions.feather"))

#Patient
patient <- read_feather(here::here("data/raw_feather/patients.feather"))

# Discharge Diagnosis
diagnoses_icd <- read_feather(here::here("data/raw_feather/diagnoses_icd.feather"))

#ICU Stays
icu_stays <- read_feather(here::here("data/raw_feather/icustays.feather"))

# Microbio
micro_bio <- read_feather(here::here("data/raw_feather/microbiologyevents.feather"))

# Prescriptions
prescriptions <- read_feather(here::here("data/raw_feather/prescriptions.feather"))
```

# Processing
# Admissions
```{r}
glimpse(admissions)
```

The following actions and transformations are required.
* Add leading zeros for Subject ID to maintain a consistent number of digits
* Row_ID does not link to any other table and can be dropped. 
* The use of "" for NA is replaced with NA
* Date-Time Objects stored as characters converted to Date-Time
* Convert boolean flags to factor
* Convert Admission Location to factor
* Convert HAMID to character.
* Replace blank with NA

```{r}
admissions_1 <- admissions %>% 
  select(-row_id) %>% 
  mutate(
    admittime = ymd_hms(admittime),
    dischtime = ymd_hms(dischtime),
    deathtime = ymd_hms(deathtime),
    edregtime = ymd_hms(edregtime),
    edouttime = ymd_hms(edouttime)
  ) %>% 
  mutate(
    hospital_expire_flag = as.factor(hospital_expire_flag),
    has_chartevents_data = as.factor(has_chartevents_data)
    
  ) %>% 
  mutate(
    subject_id = as.character(subject_id),
    hadm_id  =as.character(hadm_id)
  ) %>% 
  mutate(
    language = na_if(language,""),
    religion  = na_if(religion ,""),
    marital_status  = na_if(marital_status ,"")
    )

# Reinstate leading zeros for Subject_ID
admissions_1$subject_id  <- str_pad(
  string = admissions_1$subject_id, 
  width = 5, 
  side = "left", 
  pad = "0")
```

```{r}
admissions_1 %>% 
  head(10) 
```

```{r}
#describe(admissions_1)
```

```{r}
#skim(admissions_1)
```

Patient Information is also required. The following data from the Patients table will be joined with the admission table. Several transformations are required before joining the data frames.

* Convert Date of Birth to Date Time
* Convert Gender to Factor
* Pad leading zeros to subject_id

```{r patient_transformation}
patient_1 <- patient %>% 
  select(subject_id:dob) %>% 
  mutate(
    gender = as.factor(gender),
    dob = as_date(ymd_hms(dob)), 
    subject_id = str_pad(
      string = subject_id, 
      width = 5, 
      side = "left", 
      pad = "0"
    )
  )
```

The admission and patient data frame are joined on subject_id
```{r patient_admission_join}
admissions_2 <- admissions_1 %>% 
  left_join(patient_1, by = "subject_id")
```


```{r inspect_join}
#describe(admissions_2)
```

The following processing will be performed on the dataset:

Drop

* Type = Newborn
* Death = Yes
* Language
* Religion
* edouttime
* edregtime 
* diagnosis

Modify

* Missing Marital Status to New Variable

Create

* Calculate Length of Stay. Filter out if less than zero. This is assumed to be an error.
* Calcuate Age at Admission


```{r}
admissions_2 %>% 
  mutate(
    admitdate = as_date(admittime),
    age = round(time_length(difftime(time1 = admitdate, time2 = dob, units = "days"), unit = "years"),1)
  ) %>% 
  select(dob, admitdate, admittime, age) %>% 
  arrange() %>% 
  ggplot(mapping = aes(x = "", y = age)) + 
  geom_violin()
```


```{r}
admissions_3 <- admissions_2 %>% 
  select(-c(edregtime, edouttime, language, religion, deathtime, diagnosis)) %>% 
  filter(hospital_expire_flag == 0) %>% 
  filter(admission_type != "NEWBORN") %>% 
  select(-hospital_expire_flag) %>% 
  mutate(
    age_yr = round(time_length(difftime(time1 = as_date(admittime), time2 = dob, units = "days"), unit = "years"),1),
    length_stay_hr = round(as.numeric(difftime(time1 = dischtime, time2 = admittime, units = "hours")),1),
    marital_status = replace_na(data = marital_status, replace = "MISSING")
  ) %>% 
  filter(length_stay_hr > 0)
         
describe(admissions_3)
```

```{r age_hist}
ggplot(data = admissions_3,
       aes(x = age_yr)) + 
  geom_density()
```


Next we need to determine if and when a persons next visit was, and how long between visits.

* **next_admit_dt**: If a subject_id has multiple visits, this is the next visit date and time.
* **next_admit_type**: The type of visit.
* **admit_delta**: Length of time between visits
* **readmit_30**: Yes, if admit_delta is < 30 days

```{r}
admissions_4 <- admissions_3 %>% 
  group_by(subject_id) %>% 
  mutate(
    next_admit_dt = lead(admittime, order_by = admittime),
    next_admit_type = lead(admission_type, order_by = admittime),
    admit_span_days = round(as.numeric(difftime(time1 = next_admit_dt, time2 = admittime, units = "days")),1),
    readmit_30 = case_when(
      admit_span_days > 30 & next_admit_type != 'ELECTIVE' ~ 0,
      admit_span_days <= 30 & next_admit_type != 'ELECTIVE' ~ 1
    ),
    readmit_30 = replace_na(readmit_30,0)
  ) %>% 
  select(-c(admittime, dischtime, dob, next_admit_dt:admit_span_days)) %>% 
  ungroup()

admissions_4$readmit_30 <- as.factor(admissions_4$readmit_30)
```

```{r}
describe(admissions_4)
```

We will now add IUC stay information. The ICU stay table will be joined to the Admission table. If there is an ICU stay there will be an icustay_id associated with an hamdid. If the join returns NA there is no ICU stay.
```{r icu_join}
#Prepare ICU data frame
icu_stays_1 <- icu_stays %>% 
  select(hadm_id) %>% 
  mutate(
    hadm_id = as.character(hadm_id),
    ) %>% 
  distinct(hadm_id) %>% 
  mutate(
    icu_stay = as.factor(1)
  )

icu_stays_1 %>% 
  head()

glimpse(admissions_4)

admissions_5 <- admissions_4 %>% 
  left_join(icu_stays_1, by = "hadm_id")

glimpse(admissions_5)
```

```{r}
skim(admissions_5)
```



List of subjects with multiple admissions and admission count.
```{r}
admissions_5 %>% 
  filter(readmit_30 == 1) %>% 
  group_by(subject_id) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n))
```


## Lab Events
```{r}
glimpse(lab_events)
```

The following actions and transformations are required.
* Row_ID does not link to any other table and can be dropped. 
* The remaining ID variables should converted from integer. Subject_ID is set to factor.
* The use of "" for NA is replaced with NA
* charttime converted to date_time object
* Remove quotation marks for value and valueuom

Time zone does not matter. It is assumed every unique visit id is at the same location. We also only care about time duration, so any final time date will be ther difference between to date time values.


```{r}
lab_events_1 <- lab_events %>% 
  select(-row_id) %>% 
  mutate(
    subject_id = str_pad(
      string = subject_id, 
      width = 5, 
      side = "left", 
      pad = "0"
    ),
    hadm_id = as.character(hadm_id),
    itemid = as.character(itemid),
    valueuom = na_if(valueuom, ""),
    flag = na_if(flag, ""),
    charttime = ymd_hms(charttime)
    )
```

```{r}
glimpse(lab_events_1)
```

```{r}
#skim(lab_events_1)
```

Outpatient data is included in the Lab Events table, with hadm_id left blank. These entries will be removed.
```{r}
lab_events_2 <- lab_events_1 %>% 
  drop_na(hadm_id)

glimpse(lab_events_2)
```

With outpatient records removed we will now filter the data frame to only include itemids which we are concerted with.

```{r}
important_features = c(
  "51006", # Urea - Blood
  "51265", # Platelet Count
  "50960",
  "50862",
  "50893"
)

lab_events_3 <- lab_events_2 %>% 
  filter(itemid %in% important_features) %>% 
  select(-c(subject_id, charttime, value, valueuom)) %>% 
  mutate(
    flag = if_else(
      condition = flag == "abnormal", 
      true = 1, 
      false = 0, 
      missing = 0
    ),
    flag = as.character(flag)
  ) %>% 
  drop_na(valuenum)
```

To compute the min, mean, and max of the lab tests we have, I need to convert the data frame from long to wide.

```{r}
# Create Data frame with HADM_ID and Flag
lab_events_flag <- lab_events_3 %>% 
  select(hadm_id, flag) %>% 
  distinct()

#Remove Flag From Lab Events Data Frame
lab_events_3 <- lab_events_3 %>% 
  select(-flag)

lab_events_4 <- lab_events_3 %>% 
  group_by(hadm_id, itemid) %>% 
  mutate(
    #min = min(valuenum),
    mean = mean(valuenum)
    #max = max(valuenum)
  ) %>% 
  select(-valuenum) %>% 
  ungroup() %>% 
  distinct()

lab_events_4 %>% head()
```

In order for each item_id to be it's own variable we need to pivot this data frame.
```{r}
# lab_events_5 <- lab_events_4 %>% 
#   pivot_wider(
#     names_from = itemid, 
#     values_from = min:max
#     )
# 
# glimpse(lab_events_5)
# 
# lab_events_5 %>% head()
# 
# skim(lab_events_5)
```

Unfortunately there are too many missing values for many of the tests, except platelets (51265). In order to caputre these tests, we will drop the missing platelet tests and use the min, mean, and max. For all of the tests, including platelets, we will also develop two new columns

* ..._test_run: Indicates if a test was run
* ..._test_abnormal: If a test is run, was it abnormal


To capture if a micro-biology culture was drawn...

## Prescriptions
```{r}
#describe(prescriptions)
```

### To Do
* Using filters, check the number of NA returned using the grouping method for one test and compare to the other example.
* Create boolean category for if a microbiology sample was taken
* Drop 100 missing records for platelet tests
* Create two boolean values for each lab test, if test was taken, and if flagged.


```{r}
#sample <- sample.split(df$BAD, SplitRatio = 0.7)
```
